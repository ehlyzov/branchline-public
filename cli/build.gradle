plugins {
    id 'org.jetbrains.kotlin.multiplatform'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

kotlin {
    jvm {
        compilations.all { comp ->
            comp.kotlinOptions {
                freeCompilerArgs += ["-Xnested-type-aliases", "-Xexpect-actual-classes"]
            }
        }
        testRuns["test"].executionTask.configure {
            useJUnitPlatform()
        }
    }
    js(IR) {
        nodejs {
            binaries.executable()
        }
    }

    sourceSets {
        commonMain {
            dependencies {
                implementation project(':interpreter')
                implementation project(':vm')
                implementation 'org.jetbrains.kotlinx:kotlinx-serialization-json:1.10.0-RC'
            }
        }
        commonTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-test'
            }
        }
        jvmMain {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-stdlib'
            }
        }
        jvmTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-test'
                implementation 'org.junit.jupiter:junit-jupiter-params:5.10.2'
            }
        }
        jsMain {
            dependencies {
                implementation npm('fast-xml-parser', '4.3.5')
            }
        }
        jsTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-test'
            }
        }
    }
}

// JVM run helpers for local development
def jvmCompilation = kotlin.targets.jvm.compilations.main

def jsProductionKotlinDir = layout.buildDirectory.dir("compileSync/js/main/productionExecutable/kotlin")
def jsCliPackageDir = layout.buildDirectory.dir("cliJsPackage")
def resolveNpmExecutable = {
    def envNpmBin = System.getenv("NPM_BIN") ?: System.getenv("NVM_BIN")
    if (envNpmBin) {
        def npm = new File(envNpmBin, "npm")
        if (npm.exists()) return npm.absolutePath
    }

    def pathEnv = System.getenv("PATH") ?: ""
    for (def entry : pathEnv.split(File.pathSeparator)) {
        if (!entry) continue
        def npm = new File(entry, "npm")
        if (npm.exists()) return npm.absolutePath
    }

    def home = System.getProperty("user.home")
    def nvmRoots = [
        new File(home, ".local/share/nvm"),
        new File(home, ".nvm"),
    ]
    for (def root : nvmRoots) {
        if (!root.exists()) continue
        def candidates = root.listFiles()?.findAll { it.isDirectory() }
            ?.collect { new File(it, "bin/npm") }
            ?.findAll { it.exists() }
        if (candidates && !candidates.isEmpty()) {
            return candidates.sort { it.parentFile.parentFile.name }.last().absolutePath
        }
    }

    return null
}

tasks.register('prepareJsCliPackage') {
    group = 'build'
    description = 'Assemble the Node.js Branchline CLI bundle contents.'
    dependsOn 'jsProductionExecutableCompileSync'
    doLast {
        def targetRoot = jsCliPackageDir.get().asFile
        project.delete(targetRoot)

        // Copy compiled Kotlin JS artifacts
        copy {
            from(jsProductionKotlinDir.get().asFile)
            into(new File(targetRoot, 'kotlin'))
        }

        // Copy launcher script (ensure executable bit)
        copy {
            from("${projectDir}/js-package/bin/bl.cjs")
            into(new File(targetRoot, 'bin'))
            fileMode = 0755
        }

        // Generate package.json from template with current version
        def template = file("${projectDir}/js-package/package.json.tpl").text
        def resolved = template.replace('__VERSION__', project.version.toString())
        def pkgFile = new File(targetRoot, 'package.json')
        pkgFile.text = resolved

        def lockTemplate = file("${projectDir}/js-package/package-lock.json.tpl")
        if (!lockTemplate.exists()) {
            throw new GradleException("Missing js-package/package-lock.json.tpl; generate it via npm install --package-lock-only.")
        }
        def lockResolved = lockTemplate.text.replace('__VERSION__', project.version.toString())
        new File(targetRoot, 'package-lock.json').text = lockResolved

        // Install production dependencies so the packaged CLI ships a self-contained node_modules tree
        def npmExecutable = resolveNpmExecutable()
        if (npmExecutable == null) {
            throw new GradleException("npm executable not found; ensure NVM_BIN or PATH includes npm.")
        }
        exec {
            workingDir targetRoot
            commandLine npmExecutable, 'ci', '--omit=dev', '--ignore-scripts', '--no-audit', '--no-fund'
        }
    }
}

tasks.register('packageJsCli', org.gradle.api.tasks.bundling.Tar) {
    group = 'distribution'
    description = 'Create a distributable tarball containing the Node.js Branchline CLI.'
    dependsOn 'prepareJsCliPackage'
    archiveBaseName.set('branchline-cli-js')
    archiveVersion.set(project.version.toString())
    archiveExtension.set('tgz')
    compression = org.gradle.api.tasks.bundling.Compression.GZIP
    from(jsCliPackageDir)
}

// Fat jar for JVM CLI (java -jar branchline-cli-all.jar)
tasks.register('blShadowJar', com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
    group = 'distribution'
    description = 'Assemble a standalone JVM CLI jar with all dependencies.'
    archiveBaseName.set('branchline-cli')
    archiveClassifier.set('all')
    manifest { attributes 'Main-Class': 'io.branchline.cli.BlJvmMainKt' }
    from(kotlin.targets.jvm.compilations.main.output)
    configurations = [project.configurations.jvmRuntimeClasspath]
}

tasks.named('jvmTest') {
    dependsOn 'prepareJsCliPackage'
}

tasks.named('assemble') {
    dependsOn 'packageJsCli'
}

tasks.register('runBl', JavaExec) {
    group = 'application'
    description = 'Run Branchline CLI (bl) on the JVM target.'
    mainClass = 'io.branchline.cli.BlJvmMain'
    classpath = files(jvmCompilation.output.allOutputs, configurations.jvmRuntimeClasspath)
    dependsOn jvmCompilation.compileTaskProvider
}

tasks.register('runBlc', JavaExec) {
    group = 'application'
    description = 'Run Branchline compiler CLI (blc) on the JVM target.'
    mainClass = 'io.branchline.cli.BlcJvmMain'
    classpath = files(jvmCompilation.output.allOutputs, configurations.jvmRuntimeClasspath)
    dependsOn jvmCompilation.compileTaskProvider
}

tasks.register('runBlvm', JavaExec) {
    group = 'application'
    description = 'Run Branchline VM CLI (blvm) on the JVM target.'
    mainClass = 'io.branchline.cli.BlvmJvmMain'
    classpath = files(jvmCompilation.output.allOutputs, configurations.jvmRuntimeClasspath)
    dependsOn jvmCompilation.compileTaskProvider
}
