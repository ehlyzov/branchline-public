Коротко: «хранить дерево на стеке» в буквальном смысле возможно лишь в C/C++/Rust (и то при строгом сроке жизни). На JVM/Кotlin устойчивое древовидное хранилище на стеке — нельзя: объекты живут в куче. Чтобы получить максимальную производительность, используйте **плоские массивы примитивов** и **индексацию** (арена), а не узлы-объекты и ссылки. Это даёт кэш-локальность, минимум аллокаций и быстрый обход.

# Текущий статус в Branchline

В продакшн-коде Branchline по-прежнему используются `LinkedHashMap`/`List`-структуры для объектов и массивов. `TreeModel.ObjMap` хранит имя/индексные ключи в двух `LinkedHashMap`, а VM при исполнении тоже создаёт/копирует объекты через `LinkedHashMap`, что даёт удобство, но не оптимальные паттерны доступа к памяти.【F:interpreter/src/commonMain/kotlin/v2/TreeModel.kt†L41-L71】【F:vm/src/commonMain/kotlin/v2/vm/VM.kt†L730-L871】

Рекомендации из этого файла остаются актуальными: при переходе к арене на массивах (CSR/FCNS) можно уменьшить выделения и повысить локальность. Следующие разделы перечисляют готовые варианты структур, которые стоит внедрять постепенно.

# Что работает быстрее всего на практике

## 1) CSR («дети подряд») — build-once/read-many

* Структура: `children: IntArray`, `offset: IntArray` (или `start`, `count` для каждого узла), `parent: IntArray`, `value: <primitive arrays>`.
* Дети каждого узла лежат подряд в одном большом массиве; по `offset[u]..offset[u]+count[u]-1` итерируемся по детям.
* Плюсы: идеальная локальность, минимум памяти, самый быстрый обход/запросы поддеревьев (через префиксные диапазоны).
* Минусы: дорогие вставки/удаления (надо перекладывать хвосты).
* Используйте для больших **иммутабельных** или «построил-и-читаю» деревьев (AST, индексы).

## 2) FCNS («первый-ребёнок/следующий-брат») — частые изменения

* Структура массивов:
  `firstChild[u]: Int`, `nextSibling[u]: Int`, `parent[u]: Int`, `value…`.
* Достоинства: вставка/удаление ребёнка — O(1) амортизированно, без перекладываний больших массивов.
* Недостатки: обход немного менее локален, чем у CSR, но всё равно лучше, чем объекты.
* Выбор для **динамических** деревьев.

## 3) Эйлеров обход + диапазоны

* Храним `tin[u], tout[u]` (время входа/выхода в DFS). Поддерево = непрерывный диапазон в порядке обхода.
* Комбинируется с CSR/FCNS: ускоряет агрегации по поддереву, LCA и т.п.

# Почему массивы быстрее объектов

* Нет заголовков объектов и разыменования ссылок; меньше давления на GC.
* Последовательный доступ к памяти ⇒ лучшее попадание в кэш/предвыборку.
* На JVM JIT/escape analysis редко может «уложить» целое дерево на стек; с массивами вы это «имитируете».

# Минимальный пример арены (Kotlin/JVM)

```kotlin
@JvmInline value class Id(val i: Int)

class TreeArena(capacity: Int, edgesCapacity: Int) {
    private val parent = IntArray(capacity) { -1 }
    private val firstChild = IntArray(capacity) { -1 }
    private val nextSibling = IntArray(capacity) { -1 }
    private val value = IntArray(capacity)

    private var n = 0

    fun newNode(v: Int): Id {
        val id = Id(n++)
        value[id.i] = v
        return id
    }

    fun addChild(p: Id, c: Id) {
        parent[c.i] = p.i
        nextSibling[c.i] = firstChild[p.i]
        firstChild[p.i] = c.i
    }

    inline fun forEachChild(u: Id, f: (Id) -> Unit) {
        var c = firstChild[u.i]
        while (c != -1) { f(Id(c)); c = nextSibling[c] }
    }

    fun sumSubtree(u: Id): Long {
        var acc = 0L
        fun dfs(x: Id) {
            acc += value[x.i]
            forEachChild(x, ::dfs)
        }
        dfs(u)
        return acc
    }
}
```

Тот же подход легко переписать в CSR (храним `start[u]` и `count[u]`, а дети лежат в едином `children[]`).

# Библиотеки/инструменты

**JVM/Kotlin (рекомендовано для производительности):**

* **fastutil**, **HPPC**, **Eclipse Collections** — примитивные списки/карты без бокса. Отлично подходят как строительные блоки; для дерева всё равно делайте свои массивы.
* **Agrona** — высокопроизводительные буферы (в т.ч. off-heap), рядышком с GC-friendly структурами.
* **Chronicle Bytes/Queues** — если нужен off-heap/меммап для гигантских деревьев.

> Готовых «максимально быстрых» древовидных контейнеров под JVM практически нет — лучшие результаты даёт **собственная арена на массивах примитивов** под ваши паттерны доступа.

**Rust (если язык не фиксирован):**

* **bumpalo / typed-arena** для арен; **slotmap** (стабильные ключи), **petgraph**.
* Даёт настоящий «стекоподобный» lifetime и нулевые накладные расходы.

**C++:**

* **std::pmr::monotonic\_buffer\_resource** + ваши `std::pmr::vector` — арены «как стек».
* **boost::container::small\_vector**, **folly::F14** (для сопутствующих структур).

# Быстрый выбор по задачам

* **Построил и читаю, большие обходы, агрегации по поддеревьям** → CSR (+ эйлеровы времена).
* **Много вставок/удалений детей** → FCNS на массивах.
* **Сильно ограниченная память / off-heap** → та же схема, но через Agrona/Chronicle.
* **Нужна функциональная персистентность** → неизбежно медленнее; на JVM смотрите `kotlinx.collections.immutable`, но это уже не «максимум скорости».

# Мелкие оптимизации

* Используйте `IntArray/LongArray` и value classes для id; избегайте `List<Node>` и бокса.
* Храните данные узлов в **Struct-of-Arrays** (несколько параллельных массивов), а не один «класс Node».
* Если `n < 2^16`, храните смещения/размеры в `ShortArray`.
* Выделяйте массивы сразу «с запасом»; делайте свой рост (например, ×1.5), чтобы уменьшить копирования.
* Для многопоточности — храните дерево иммутабельным (CSR) и параллелите обходы по диапазонам.

---

Если опишете ваши операции (сколько вставок/удалений, какие запросы, размеры, есть ли off-heap/GC-ограничения), я подберу конкретную схему (CSR или FCNS), дам точные поля массивов и шаблон бенчмарков JMH.
