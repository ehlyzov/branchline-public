SHARED jmh MANY;

FUNC engineRank(engine) = CASE {
    WHEN engine == "kotlin" THEN 0
    WHEN engine == "branchline-interpreter" THEN 1
    WHEN engine == "branchline-vm" THEN 2
    WHEN engine == "dashjoin" THEN 3
    WHEN engine == "ibm" THEN 4
    ELSE 99
};

FUNC formatNumber(value) {
    IF value == NULL THEN {
        RETURN "n/a";
    }
    RETURN STRING(ROUND(value, 3));
}

FUNC formatRatio(value) {
    IF value == NULL THEN {
        RETURN "n/a";
    }
    RETURN STRING(value) + "x";
}

FUNC formatSpeedup(value) {
    IF value == NULL THEN {
        RETURN "n/a";
    }
    RETURN formatNumber(value) + "x";
}

FUNC isDisplayEngine(engine) {
    RETURN engine == "branchline-interpreter"
        || engine == "branchline-vm"
        || engine == "dashjoin"
        || engine == "ibm";
}

FUNC buildSortKey(row, idx) {
    LET engineKey = PAD(STRING(INT(engineRank(row.engine))), -2, "0");
    LET caseKey = STRING(row.caseId);
    LET indexKey = PAD(STRING(INT(idx)), -4, "0");
    RETURN engineKey + "::" + caseKey + "::" + indexKey;
}

FUNC sortRows(rows) {
    LET keys = [];
    LET idx = 0;
    FOR row IN rows {
        SET keys = APPEND(keys, buildSortKey(row, idx));
        SET idx = idx + 1;
    }
    LET sortedKeys = SORT(keys);
    LET out = [];
    FOR key IN sortedKeys {
        LET parts = SPLIT(key, "::");
        LET pos = INT(parts[2]);
        SET out = APPEND(out, rows[pos]);
    }
    RETURN out;
}

FUNC findScore(rows, caseId, engineId) {
    FOR row IN rows {
        IF row.caseId == caseId && row.engine == engineId THEN {
            RETURN row.score;
        }
    }
    RETURN NULL;
}

FUNC resolveFastestJsonata(ibmScore, dashjoinScore) {
    IF ibmScore == NULL && dashjoinScore == NULL THEN {
        RETURN { engine: NULL, score: NULL };
    }
    IF dashjoinScore == NULL THEN {
        RETURN { engine: "ibm", score: ibmScore };
    }
    IF ibmScore == NULL THEN {
        RETURN { engine: "dashjoin", score: dashjoinScore };
    }
    IF dashjoinScore >= ibmScore THEN {
        RETURN { engine: "dashjoin", score: dashjoinScore };
    }
    RETURN { engine: "ibm", score: ibmScore };
}

FUNC sumValues(values) {
    LET total = 0;
    FOR value IN values {
        SET total = total + value;
    }
    RETURN total;
}

FUNC maxValue(values) {
    LET max = NULL;
    FOR value IN values {
        IF max == NULL || value > max THEN {
            SET max = value;
        }
    }
    RETURN max;
}

FUNC medianValue(values) {
    LET count = LENGTH(values);
    IF count == 0 THEN {
        RETURN NULL;
    }
    LET sorted = SORT(values);
    LET half = INT(count / 2);
    LET isEven = count == half * 2;
    IF isEven THEN {
        LET left = sorted[half - 1];
        LET right = sorted[half];
        RETURN (left + right) / 2;
    }
    RETURN sorted[half];
}

FUNC collectScores(rows, caseIds, engineId) {
    LET scores = [];
    FOR caseId IN caseIds {
        LET score = findScore(rows, caseId, engineId);
        IF score != NULL THEN {
            SET scores = APPEND(scores, score);
        }
    }
    RETURN scores;
}

FUNC filterDashjoinAnomalies(rows, caseIds) {
    LET scores = collectScores(rows, caseIds, "dashjoin");
    LET median = medianValue(scores);
    IF median == NULL THEN {
        RETURN { included: caseIds, excluded: [], median: NULL, upper: NULL };
    }
    LET upper = median * 100;
    LET included = [];
    LET excluded = [];
    FOR caseId IN caseIds {
        LET score = findScore(rows, caseId, "dashjoin");
        IF score == NULL THEN {
            SET excluded = APPEND(excluded, caseId);
        } ELSE {
            IF score > upper THEN {
                SET excluded = APPEND(excluded, caseId);
            } ELSE {
                SET included = APPEND(included, caseId);
            }
        }
    }
    RETURN { included: included, excluded: excluded, median: median, upper: upper };
}

FUNC collectSpeedups(rows, caseIds, branchEngine, jsonataEngine) {
    LET fasterRatios = [];
    LET total = 0;
    FOR caseId IN caseIds {
        LET branchScore = findScore(rows, caseId, branchEngine);
        LET jsonataScore = findScore(rows, caseId, jsonataEngine);
        IF branchScore != NULL && jsonataScore != NULL THEN {
            SET total = total + 1;
            LET ratio = branchScore / jsonataScore;
            IF ratio > 1 THEN {
                SET fasterRatios = APPEND(fasterRatios, ratio);
            }
        }
    }
    LET fasterCount = LENGTH(fasterRatios);
    LET avgSpeedup = CASE {
        WHEN fasterCount == 0 THEN NULL
        ELSE sumValues(fasterRatios) / fasterCount
    };
    LET maxSpeedup = CASE {
        WHEN fasterCount == 0 THEN NULL
        ELSE maxValue(fasterRatios)
    };
    RETURN {
        fasterCount: fasterCount,
        total: total,
        avgSpeedup: avgSpeedup,
        maxSpeedup: maxSpeedup
    };
}

FUNC buildSpeedupSummary(rows, caseIds) {
    LET lines = [];
    SET lines = APPEND(lines, "### Branchline speedup summary");
    SET lines = APPEND(lines, "");
    SET lines = APPEND(lines, "Counts include cases where both engines have scores. Speedup is Branchline ops/s divided by Dashjoin ops/s.");
    SET lines = APPEND(lines, "");
    SET lines = APPEND(lines, "| Comparison | Faster cases | Total cases | Avg speedup (faster cases) | Max speedup |");
    SET lines = APPEND(lines, "| --- | ---: | ---: | ---: | ---: |");

    LET comparisons = [
        { label: "Interpreter vs Dashjoin", branch: "branchline-interpreter", jsonata: "dashjoin" },
        { label: "VM vs Dashjoin", branch: "branchline-vm", jsonata: "dashjoin" }
    ];
    FOR comp IN comparisons {
        LET summary = collectSpeedups(rows, caseIds, comp.branch, comp.jsonata);
        LET line = "| " + comp.label
            + " | " + STRING(summary.fasterCount)
            + " | " + STRING(summary.total)
            + " | " + formatSpeedup(summary.avgSpeedup)
            + " | " + formatSpeedup(summary.maxSpeedup)
            + " |";
        SET lines = APPEND(lines, line);
    }
    SET lines = APPEND(lines, "");
    RETURN JOIN(lines, "\n");
}

FUNC buildMarkdown(rows) {
    LET display = [];
    FOR row IN rows {
        IF isDisplayEngine(row.engine) THEN {
            SET display = APPEND(display, row);
        }
    }
    LET cases = [];
    FOR row IN display {
        SET cases = APPEND(cases, row.caseId);
    }
    LET caseIds = SORT(DISTINCT(cases));

    LET lines = [];
    SET lines = APPEND(lines, "## JSONata cross-engine results");
    SET lines = APPEND(lines, "");
    SET lines = APPEND(lines, "Source data: [CSV](jsonata-summary.csv).");
    SET lines = APPEND(lines, "");
    SET lines = APPEND(lines, "Scores are throughput in ops/s (higher is faster). Ratios compare Branchline throughput to the fastest JSONata engine.");
    SET lines = APPEND(lines, "");
    LET dashjoinFilter = filterDashjoinAnomalies(display, caseIds);
    LET filteredCaseIds = dashjoinFilter.included;
    LET excludedCaseIds = dashjoinFilter.excluded;
    SET lines = APPEND(lines, "Dashjoin outliers are excluded from the summary and breakdown (outside 0.01xâ€“100x Dashjoin median).");
    IF LENGTH(excludedCaseIds) > 0 THEN {
        SET lines = APPEND(lines, "");
        SET lines = APPEND(lines, "Excluded cases: " + JOIN(excludedCaseIds, ", ") + ".");
    }
    SET lines = APPEND(lines, "");
    SET lines = APPEND(lines, buildSpeedupSummary(display, filteredCaseIds));
    SET lines = APPEND(lines, "### Case breakdown");
    SET lines = APPEND(lines, "| Case | Branchline Interpreter (ops/s) | Branchline VM (ops/s) | Fastest JSONata (ops/s) | Fastest JSONata engine | Interpreter vs JSONata | VM vs JSONata |");
    SET lines = APPEND(lines, "| --- | ---: | ---: | ---: | --- | ---: | ---: |");
    FOR caseId IN filteredCaseIds {
        LET interp = findScore(display, caseId, "branchline-interpreter");
        LET vm = findScore(display, caseId, "branchline-vm");
        LET dashjoin = findScore(display, caseId, "dashjoin");
        LET ibm = findScore(display, caseId, "ibm");
        LET fastest = resolveFastestJsonata(ibm, dashjoin);
        LET fastestEngine = CASE {
            WHEN fastest.engine == NULL THEN "n/a"
            ELSE fastest.engine
        };
        LET interpRatio = CASE {
            WHEN interp == NULL || fastest.score == NULL THEN NULL
            ELSE interp / fastest.score
        };
        LET vmRatio = CASE {
            WHEN vm == NULL || fastest.score == NULL THEN NULL
            ELSE vm / fastest.score
        };
        LET line = "| " + caseId
            + " | " + formatNumber(interp)
            + " | " + formatNumber(vm)
            + " | " + formatNumber(fastest.score)
            + " | " + fastestEngine
            + " | " + formatRatio(interpRatio)
            + " | " + formatRatio(vmRatio)
            + " |";
        SET lines = APPEND(lines, line);
    }
    RETURN JOIN(lines, "\n");
}

FUNC buildCsv(rows) {
    LET lines = ["engine,case,score,score_error,unit"];
    FOR row IN rows {
        LET line = row.engine + "," + row.caseId + "," + formatNumber(row.score) + "," + formatNumber(row.scoreError) + "," + row.unit;
        SET lines = APPEND(lines, line);
    }
    RETURN JOIN(lines, "\n");
}

TRANSFORM JsonataReport {
    LET raw = [];
    FOR key IN KEYS(jmh) {
        SET raw = APPEND(raw, LISTIFY(AWAIT_SHARED("jmh", key)));
    }
    LET entries = FLATTEN(raw);
    LET rows = [];
    FOR entry IN entries {
        LET params = entry.params ?? {};
        LET engine = params.engineId ?? NULL;
        IF engine != NULL THEN {
            LET caseId = params.caseId ?? "";
            LET primary = entry.primaryMetric ?? {};
            SET rows = APPEND(rows, {
                engine: engine,
                caseId: caseId,
                score: primary.score,
                scoreError: primary.scoreError,
                unit: primary.scoreUnit ?? ""
            });
        }
    }
    LET sorted = sortRows(rows);
    LET markdown = buildMarkdown(sorted);
    LET csv = buildCsv(sorted);

    OUTPUT {
        rows: LENGTH(sorted),
        files: {
            "jsonata-summary.md": markdown,
            "jsonata-summary.csv": csv
        }
    };
}
