cases:
  - id: sum_prices
    jsonataExpression: '{"value": $sum(items.price)}'
    inputJson: '{"items":[{"price":10},{"price":20},{"price":30}]}'
    branchlineProgram: |
      TRANSFORM SumPrices {
          OUTPUT {
              value: SUM(MAP(input.items, (item) -> item.price)),
          };
      }
    kotlinEvalId: sum_prices
  - id: filter_names
    jsonataExpression: '{"items": items[price > 10].name}'
    inputJson: '{"items":[{"name":"a","price":5},{"name":"b","price":15},{"name":"c","price":25}]}'
    branchlineProgram: |
      TRANSFORM FilterNames {
          OUTPUT {
              items: MAP(
                  FILTER(input.items, (item) -> item.price > 10),
                  (item) -> item.name
              ),
          };
      }
    kotlinEvalId: filter_names
  - id: map_discount
    jsonataExpression: '{"items": $map(items, function($v){$v.price * 1.1})}'
    inputJson: '{"items":[{"price":100},{"price":150},{"price":200}]}'
    branchlineProgram: |
      TRANSFORM MapDiscount {
          OUTPUT {
              items: MAP(input.items, (item) -> item.price * 1.1),
          };
      }
    kotlinEvalId: map_discount
  - id: summary_stats
    jsonataExpression: '{"count": $count(items), "avg": $average(items.price)}'
    inputJson: '{"items":[{"price":4},{"price":6},{"price":10}]}'
    branchlineProgram: |
      TRANSFORM SummaryStats {
          OUTPUT {
              count: COUNT(input.items),
              avg: AVG(MAP(input.items, (item) -> item.price)),
          };
      }
    kotlinEvalId: summary_stats
  - id: function-sift/case004
    branchlineProgram: |
      TRANSFORM FunctionSiftCase004 {
          LET data = { a: "hello", b: "world", hello: "again" }
          LET result = {}
          FOR EACH key in KEYS(data) WHERE GET(data, data[key]) != NULL {
            SET result.[key] = data[key]
          }
          OUTPUT result;
      }
    kotlinEvalId: "function-sift/case004"
  - id: hof-map/case000
    branchlineProgram: |
      TRANSFORM HofMapCase000 {
          LET data = {
              one: [1, 2, 3, 4, 5],
              two: [5, 4, 3, 2, 1],
          }
          LET fn = (x) -> x * x
          OUTPUT { result: MAP(data.one, fn) }
      }
    kotlinEvalId: "hof-map/case000"
  - id: function-zip/case002
    branchlineProgram: |
      TRANSFORM FunctionZipCase002 {
          LET first = [1, 2, 3];
          LET second = [4, 5];
          LET third = [7, 8, 9];
          LET limit = MIN([LENGTH(first), LENGTH(second), LENGTH(third)]);
          OUTPUT {
            result: MAP(RANGE(0, limit - 1), (i) -> [first[i], second[i], third[i]])
          }
      }
    kotlinEvalId: "function-zip/case002"
  - id: hof-zip-map/case000
    branchlineProgram: |
      TRANSFORM HofZipMapCase000 {
          LET data = {
              one: [1, 2, 3, 4, 5],
              two: [5, 4, 3, 2, 1],
          };
          LET pairs = ZIP(data.one, data.two);
          OUTPUT {
            result: MAP(pairs, (pair) -> pair[0] + pair[1])
          }
      }
    kotlinEvalId: "hof-zip-map/case000"
  - id: partial-application/case002
    branchlineProgram: |
      TRANSFORM PartialApplicationCase002 {
          OUTPUT {
            result: SUBSTRING("Hello World", 0, 5)
          }
      }
    kotlinEvalId: "partial-application/case002"
  - id: function-sum/case000
    branchlineProgram: |
      TRANSFORM FunctionSumCase000 {
          LET totals = FLATTEN(MAP(input.Account.Order, (order) -> MAP(order.Product, (product) -> product.Price * product.Quantity)));
          OUTPUT { result: SUM(totals) }
      }
    kotlinEvalId: "function-sum/case000"
  - id: function-count/case000
    branchlineProgram: |
      TRANSFORM FunctionCountCase000 {
          LET totals = FLATTEN(MAP(input.Account.Order, (order) -> MAP(order.Product, (product) -> product.Price * product.Quantity)));
          OUTPUT { result: COUNT(totals) }
      }
    kotlinEvalId: "function-count/case000"
  - id: simple-array-selectors/case000
    branchlineProgram: |
      TRANSFORM SimpleArraySelectorsCase000 {
          LET values = FLATTEN(MAP(input, (item) -> MAP(item.nest0, (entry) -> entry.nest1[0])));
          OUTPUT { result: FLATTEN(values) }
      }
    kotlinEvalId: "simple-array-selectors/case000"
  - id: fields/case000
    branchlineProgram: |
      TRANSFORM FieldsCase000 {
          OUTPUT { result: input.foo.bar }
      }
    kotlinEvalId: "fields/case000"
  - id: numeric-operators/case000
    branchlineProgram: |
      TRANSFORM NumericOperatorsCase000 {
          OUTPUT { result: input.foo.bar + input.bar }
      }
    kotlinEvalId: "numeric-operators/case000"
  - id: string-concat/case000
    branchlineProgram: |
      TRANSFORM StringConcatCase000 {
          OUTPUT { result: "foo" + "bar" };
      }
    kotlinEvalId: "string-concat/case000"
  - id: range-operator/case000
    branchlineProgram: |
      TRANSFORM RangeOperatorCase000 {
          OUTPUT { result: RANGE(0, 9) }
      }
    kotlinEvalId: "range-operator/case000"
  - id: performance/case001
    branchlineProgram: |
      TRANSFORM PerformanceCase001 {
          LET items = input.items;
          LET filtered = FILTER(items, (item) -> item.text != "" && item.text != "test");
          LET size = LENGTH(items);
          OUTPUT {
              items: [
                {
                  foo: "bar",
                  label: JOIN([items[index].label, filtered[index].text], " "),
                } 
                FOR EACH index IN RANGE(0, size - 1)
              ]
          };
      }
    kotlinEvalId: "performance/case001"
